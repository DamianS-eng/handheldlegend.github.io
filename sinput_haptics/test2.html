<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haptic Streaming Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            color: #2d3748;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            font-size: 1.1rem;
            margin-bottom: 40px;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .file-input-wrapper {
            position: relative;
            display: block;
            cursor: pointer;
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .file-input-wrapper:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4ff, #e6f0ff);
            transform: translateY(-2px);
        }

        .file-input-wrapper.dragover {
            border-color: #667eea;
            background: linear-gradient(135deg, #e6f0ff, #dce7ff);
            transform: scale(1.02);
        }

        #fileInput {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-content {
            pointer-events: none;
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 15px;
            opacity: 0.6;
        }

        .file-input-text {
            font-size: 1.1rem;
            color: #4a5568;
            font-weight: 500;
        }

        .file-input-hint {
            font-size: 0.9rem;
            color: #718096;
            margin-top: 5px;
        }

        .button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .button:active:not(:disabled) {
            transform: translateY(0);
        }

        .button:disabled {
            background: linear-gradient(135deg, #a0aec0, #cbd5e0);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .button.secondary {
            background: linear-gradient(135deg, #38b2ac, #319795);
            box-shadow: 0 4px 15px rgba(56, 178, 172, 0.3);
        }

        .button.secondary:hover:not(:disabled) {
            box-shadow: 0 8px 25px rgba(56, 178, 172, 0.4);
        }

        .status-section {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
            border-left: 4px solid #667eea;
        }

        .status-title {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .status-text {
            color: #718096;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .file-info {
            background: linear-gradient(135deg, #f0fff4, #e6ffed);
            border: 1px solid #9ae6b4;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #22543d;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .streaming {
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            .container {
                padding: 25px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .button {
                padding: 12px 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Haptic Streaming</h1>
        <p class="subtitle">Stream audio files to your haptic device with real-time encoding</p>
        
        <div class="control-section">
            <div class="section-title">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                </svg>
                Audio File
            </div>
            
            <label class="file-input-wrapper" for="fileInput">
                <input type="file" id="fileInput" accept=".wav,.mp3,.m4a,.ogg">
                <div class="file-input-content">
                    <svg class="upload-icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                    </svg>
                    <div class="file-input-text">Choose audio file or drag & drop</div>
                    <div class="file-input-hint">Supports WAV, MP3, M4A, OGG formats</div>
                </div>
            </label>
            
            <div id="fileInfo" class="file-info" style="display: none;"></div>
        </div>

        <div class="control-section">
            <div class="section-title">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M8,12A2,2 0 0,1 10,10A2,2 0 0,1 12,12A2,2 0 0,1 10,14A2,2 0 0,1 8,12M20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12Z"/>
                </svg>
                Device Connection
            </div>
            
            <button id="connectButton" class="button">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M4,1C2.89,1 2,1.89 2,3V7C2,8.11 2.89,9 4,9H1V11H13V9H10C11.11,9 12,8.11 12,7V3C12,1.89 11.11,1 10,1H4M4,3H10V7H4V3M3,13V18L3,19H21V18V13H3M20,15H19V17H20V15Z"/>
                </svg>
                Connect Haptic Device
            </button>
        </div>

        <div class="control-section">
            <div class="section-title">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                </svg>
                Streaming Control
            </div>
            
            <button id="startButton" class="button secondary" disabled>
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                </svg>
                Start Streaming
            </button>
            
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
        </div>

        <div class="status-section">
            <div class="status-title">Status</div>
            <div id="statusText" class="status-text">Ready to load audio file and connect device</div>
        </div>
    </div>

    <script>
    // === Configuration ===
    const VENDOR_ID  = 0x2E8A;
    const PRODUCT_ID = 0x10C6;
    const REPORT_ID  = 0x02;      // HID output report ID for PCM data
    const INPUT_ID   = 0x01;      // HID input report ID
    const CHUNK_MS   = 6;         // each packet ≈6ms of audio
    const SAMPLE_RATE = 16000;    // target sample rate
    const CHANNELS    = 1;        // mono
    const SAMPLE_SIZE = 2;        // bytes per sample (16-bit)
    const INTERVAL_MS = 4;        // send every 4ms
    const SAMPLES_PER_CHUNK = Math.ceil(SAMPLE_RATE * CHUNK_MS / 1000); // ≈96

    // ADPCM tables (IMA-ADPCM)
    const stepSizeTable = [
         7, 8, 9, 10, 11, 12, 13, 14, 16, 17,
         19,21,23,25,28,31,34,37,41,45,
         50,55,60,66,73,80,88,97,107,118,
         130,143,157,173,190,209,230,253,279,307,
         337,371,408,449,494,544,598,658,724,796,
         876,963,1060,1166,1282,1411,1552,1707,1878,2066,
         2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,
         5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,
         15289,16818,18500,20350,22385,24623,27086,29794,32767
    ];
    const indexTable = [
        -1, -1, -1, -1, 2, 4, 6, 8,
        -1, -1, -1, -1, 2, 4, 6, 8
    ];

    // State
    let hidDevice     = null;
    let allowSend     = true;
    let adpcmBlocks   = [];
    let sendIndex     = 0;
    let sendTimer     = null;
    let isConnected   = false;
    let isStreaming   = false;

    // === UI elements ===
    const fileInput     = document.getElementById('fileInput');
    const connectButton = document.getElementById('connectButton');
    const startButton   = document.getElementById('startButton');
    const statusText    = document.getElementById('statusText');
    const fileInfo      = document.getElementById('fileInfo');
    const progressFill  = document.getElementById('progressFill');
    const fileWrapper   = document.querySelector('.file-input-wrapper');

    // === Drag and drop support ===
    fileWrapper.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileWrapper.classList.add('dragover');
    });

    fileWrapper.addEventListener('dragleave', () => {
        fileWrapper.classList.remove('dragover');
    });

    fileWrapper.addEventListener('drop', (e) => {
        e.preventDefault();
        fileWrapper.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            fileInput.files = files;
            fileInput.dispatchEvent(new Event('change'));
        }
    });

    // === File handling ===
    fileInput.addEventListener('change', async () => {
        const file = fileInput.files[0];
        if (!file) return;
        
        updateStatus('Processing audio file...');
        adpcmBlocks = [];
        sendIndex = 0;
        progressFill.style.width = '0%';

        try {
            // 1. Decode & normalize to mono float32 @ 16kHz
            const int16Data = await processAudio(file);
            
            // 2. Chunk into 6ms pieces and ADPCM‐encode each
            for (let i = 0; i < int16Data.length; i += SAMPLES_PER_CHUNK) {
                let slice = int16Data.subarray(i, i + SAMPLES_PER_CHUNK);
                if (slice.length < SAMPLES_PER_CHUNK) {
                    // pad with zeros
                    const padded = new Int16Array(SAMPLES_PER_CHUNK);
                    padded.set(slice);
                    slice = padded;
                }
                adpcmBlocks.push(adpcmEncode(slice));
            }
            
            const duration = (int16Data.length / SAMPLE_RATE).toFixed(2);
            const fileSize = (file.size / 1024).toFixed(1);
            
            fileInfo.innerHTML = `
                <strong>${file.name}</strong><br>
                Duration: ${duration}s | Size: ${fileSize}KB | Blocks: ${adpcmBlocks.length}
            `;
            fileInfo.style.display = 'block';
            
            updateStatus(`Audio file processed successfully. ${adpcmBlocks.length} blocks ready for streaming.`);
            
            if (isConnected) {
                startButton.disabled = false;
            }
        } catch (error) {
            console.error('Audio processing error:', error);
            updateStatus('Error processing audio file. Please try a different file.');
            fileInfo.style.display = 'none';
        }
    });

    // === WebHID connection ===
    connectButton.addEventListener('click', async () => {
        try {
            updateStatus('Requesting device access...');
            const devices = await navigator.hid.requestDevice({
                filters: [{ vendorId: VENDOR_ID, productId: PRODUCT_ID }]
            });
            if (!devices.length) {
                updateStatus('No device selected.');
                return;
            }
            hidDevice = devices[0];
            await hidDevice.open();
            hidDevice.addEventListener('inputreport', onInputReport);
            
            isConnected = true;
            connectButton.innerHTML = `
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/>
                </svg>
                Device Connected
            `;
            connectButton.style.background = 'linear-gradient(135deg, #38a169, #2f855a)';
            
            updateStatus('Haptic device connected successfully.');
            
            if (adpcmBlocks.length) {
                startButton.disabled = false;
            }
        } catch (e) {
            console.error(e);
            updateStatus('Failed to connect to device: ' + e.message);
        }
    });

    // === Start streaming ===
    startButton.addEventListener('click', () => {
        if (!hidDevice || !hidDevice.opened || !adpcmBlocks.length) {
            updateStatus('Please load an audio file and connect the device first.');
            return;
        }
        
        if (isStreaming) {
            // Stop streaming
            if (sendTimer) clearInterval(sendTimer);
            isStreaming = false;
            startButton.innerHTML = `
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                </svg>
                Start Streaming
            `;
            startButton.classList.remove('streaming');
            updateStatus('Streaming stopped.');
            return;
        }
        
        sendIndex = 0;
        allowSend = true;
        isStreaming = true;
        
        startButton.innerHTML = `
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M6,19H10V5H6V19Z M14,5V19H18V5H14Z"/>
            </svg>
            Stop Streaming
        `;
        startButton.classList.add('streaming');
        
        updateStatus('Streaming audio to haptic device...');
        
        if (sendTimer) clearInterval(sendTimer);
        sendTimer = setInterval(() => {
            if (!allowSend) return;
            if (sendIndex >= adpcmBlocks.length) {
                clearInterval(sendTimer);
                isStreaming = false;
                startButton.innerHTML = `
                    <svg class="icon" viewBox="0 0 24 24">
                        <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                    </svg>
                    Start Streaming
                `;
                startButton.classList.remove('streaming');
                updateStatus('Streaming completed successfully.');
                progressFill.style.width = '100%';
                return;
            }
            sendBlock(sendIndex++);
            
            // Update progress
            const progress = (sendIndex / adpcmBlocks.length) * 100;
            progressFill.style.width = progress + '%';
        }, INTERVAL_MS);
    });

    // === Input report handler ===
    function onInputReport(event) {
        if (event.reportId !== INPUT_ID) return;
        const status = event.data.getUint8(32);  // byte 33
        allowSend = (status === 0x00);
    }

    // === Send one block ===
    async function sendBlock(idx) {
        const cmd = adpcmBlocks[idx];
        // Payload: [ type, length, ...adpcm_data ]
        const payload = new Uint8Array(2 + cmd.length);
        payload[0] = 0x00;           // type=0 for PCM
        payload[1] = cmd.length;     // ADPCM length
        payload.set(cmd, 2);
        try {
            await hidDevice.sendReport(REPORT_ID, payload);
        } catch (e) {
            console.error('sendReport failed:', e);
            updateStatus('Error sending data to device.');
        }
    }

    // === Audio processing (enhanced resampling) ===
    async function processAudio(file) {
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded  = await audioCtx.decodeAudioData(arrayBuffer);
        
        // Mix to mono if needed
        let monoData;
        if (decoded.numberOfChannels === 1) {
            monoData = decoded.getChannelData(0);
        } else {
            const len = decoded.length;
            monoData = new Float32Array(len);
            for (let i = 0; i < len; i++) {
                let sum = 0;
                for (let ch = 0; ch < decoded.numberOfChannels; ch++) {
                    sum += decoded.getChannelData(ch)[i];
                }
                monoData[i] = sum / decoded.numberOfChannels;
            }
        }
        
        // Enhanced resampling to 16kHz with anti-aliasing
        const resampled = resample(monoData, decoded.sampleRate, SAMPLE_RATE);
        
        // Convert float32 → 16-bit PCM with proper clamping
        const int16 = new Int16Array(resampled.length);
        for (let i = 0; i < resampled.length; i++) {
            const s = Math.max(-1, Math.min(1, resampled[i]));
            int16[i] = Math.round(s < 0 ? s * 0x8000 : s * 0x7FFF);
        }
        return int16;
    }

    // === Enhanced linear interpolation resampler ===
    function resample(data, inRate, outRate) {
        if (inRate === outRate) return data;
        
        const outLen = Math.round(data.length * outRate / inRate);
        const out    = new Float32Array(outLen);
        const ratio  = data.length / outLen;
        
        for (let i = 0; i < outLen; i++) {
            const srcIndex = i * ratio;
            const i0 = Math.floor(srcIndex);
            const i1 = Math.min(i0 + 1, data.length - 1);
            const frac = srcIndex - i0;
            
            // Linear interpolation
            out[i] = data[i0] * (1 - frac) + data[i1] * frac;
        }
        return out;
    }

    // === IMA ADPCM encoder for one block ===
    function adpcmEncode(samples) {
        let predictor = samples[0];
        let index     = 0;
        let step      = stepSizeTable[index];
        const outBuf  = [];
        // Header: predictor (LE), index, reserved
        outBuf.push(predictor & 0xFF, (predictor >> 8) & 0xFF, index, 0);
        let nibbleBuf = 0, haveHigh = false;
        for (let i = 1; i < samples.length; i++) {
            let diff = samples[i] - predictor;
            let sign = diff < 0 ? 8 : 0;
            diff = Math.abs(diff);
            let delta = 0;
            let temp  = step;
            if (diff >= temp) { delta = 4; diff -= temp; }
            temp >>= 1;
            if (diff >= temp) { delta |= 2; diff -= temp; }
            temp >>= 1;
            if (diff >= temp) { delta |= 1; }
            delta |= sign;
            // update predictor
            let diffq = step >> 3;
            if (delta & 4) diffq += step;
            if (delta & 2) diffq += step >> 1;
            if (delta & 1) diffq += step >> 2;
            predictor += (sign ? -diffq : diffq);
            predictor = Math.max(-32768, Math.min(32767, predictor));
            // update index & step
            index += indexTable[delta & 0xF];
            index = Math.max(0, Math.min(88, index));
            step = stepSizeTable[index];
            // pack nibble
            if (!haveHigh) {
                nibbleBuf = delta & 0xF;
                haveHigh = true;
            } else {
                outBuf.push(((delta & 0xF) << 4) | nibbleBuf);
                haveHigh = false;
            }
        }
        if (haveHigh) {
            outBuf.push(nibbleBuf);
        }
        return new Uint8Array(outBuf);
    }

    // === UI helper functions ===
    function updateStatus(message) {
        statusText.textContent = message;
    }
    </script>
</body>
</html>